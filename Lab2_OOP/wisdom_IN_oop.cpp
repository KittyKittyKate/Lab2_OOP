#include "wisdom_oop.h"
// Необходима подключить информацию обо всех имеющихся
// геометрических фигурах
#include "aphorism_oop.h"
#include "proverb_oop.h"
#include "puzzle_oop.h"
#include <iostream>
#include <string>
using namespace std;
namespace collection_of_wisdom_oop {
	// Ввод параметров обобщенной фигуры
	wisdom* wisdom::In(ifstream &ifst) {
		wisdom *sp;
		int k;
		ifst >> k;
		switch (k) {
		case 1:
			sp = new aphorism;
			break;
		case 2:
			sp = new proverb;
			break;
		case 3:
			sp = new puzzle;
			break;
		default: //Если попадаем сюда, то застрянем. Временное решение: пусть мудрость с неправильным ключом просто не будет заноситься в контейнер
			char Junk[100]; //для мусора
			ifst.getline(Junk, 100); //Здесь - выражение
			ifst.getline(Junk, 100); //Здесь - уникальная характеристика
			ifst.getline(Junk, 100); //Здесь - оценка
			return 0;
		}
		string Line; //Временное решение на случай переполнения
		getline(ifst, Line); //Строка заносится в Line
		if (Line.length() < 100) { //Проверка на переполнение - если длина Line < 100
			strcpy_s(sp->expression, 100, Line.c_str());
			sp->InData(ifst);
			ifst >> sp->rate;
			return sp;
		}
		else { //иначе придется отсечь лишнее
			Line.resize(99);
			strcpy_s(sp->expression, 100, Line.c_str());
			sp->InData(ifst);
			ifst >> sp->rate;
			return sp;
		}
		Line.clear();
	}
	bool wisdom::Compare(wisdom &other) {
		return Count_Comma() > other.Count_Comma(); 
	}
	int wisdom::Count_Comma() {
		int comma = 0;
		int i = 0;
		while (this->expression[i] != '\0')
		{
			if (this->expression[i] == ',') {
				comma++;
			}
			i++;
		}
		return comma;
	}
	void wisdom::OutAphorism(ofstream &ofst, wisdom *sp) {
		ofst << endl; 
	}
} // end collection_of_wisdom_oop namespace